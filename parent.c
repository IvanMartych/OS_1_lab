#include <unistd.h>   // Для системных вызовов: read, write, pipe, fork, close, STDIN_FILENO, STDOUT_FILENO
#include <sys/wait.h> // Для ожидания завершения дочерних процессов: wait
#include <stdlib.h>   // Для работы с памятью и процессами: exit
#include <string.h>   // Для работы со строками: strstr
#include <fcntl.h>    // Для работы с файлами: open, O_* константы

/**
 * Функция для записи строки в файловый дескриптор
 * Вместо printf используем системный вызов write
 * @param fd - файловый дескриптор для записи
 * @param str - строка для записи
 */
void write_str(int fd, const char* str) {
    int len = 0;
    // Вручную подсчитываем длину строки (аналог strlen)
    while (str[len] != '\0') len++;
    // Записываем строку с помощью системного вызова
    write(fd, str, len);
}

/**
 * Главная функция родительского процесса
 * Управляет взаимодействием с пользователем и дочерним процессом
 */
int main() {
    int pipe1[2]; // Массив для создания pipe: pipe1[0] - чтение, pipe1[1] - запись
    
    // Создание pipe для межпроцессного взаимодействия
    // pipe1 будет использоваться для передачи данных от родителя к ребенку
    if (pipe(pipe1) == -1) {
        write_str(STDERR_FILENO, "Error: pipe creation failed\n");
        return 1; // Завершаем программу с ошибкой
    }
    
    // Запрос имени файла у пользователя для сохранения результатов
    write_str(STDOUT_FILENO, "Enter filename: ");
    char filename[256]; // Буфер для хранения имени файла
    // Чтение ввода пользователя с помощью системного вызова read
    int bytes = read(STDIN_FILENO, filename, sizeof(filename) - 1);
    filename[bytes] = '\0'; // Завершаем строку нулевым символом
    
    // Убираем символ новой строки из имени файла
    for (int i = 0; filename[i] != '\0'; i++) {
        if (filename[i] == '\n') {
            filename[i] = '\0'; // Заменяем \n на конец строки
            break;
        }
    }
    
    // Создание дочернего процесса с помощью fork()
    // После fork() программа разделяется на два идентичных процесса
    pid_t pid = fork();
    
    // Проверка на ошибку создания процесса
    if (pid == -1) {
        write_str(STDERR_FILENO, "Error: fork failed\n");
        return 1;
    }
    
    // Код для ДОЧЕРНЕГО процесса (pid == 0)
    if (pid == 0) {
        // Дочерний процесс наследует открытые файловые дескрипторы родителя
        
        // Закрываем конец pipe для ЗАПИСИ, так как ребенок только читает
        close(pipe1[1]);
        
        // Перенаправляем стандартный ввод (stdin) дочернего процесса на чтение из pipe
        // Теперь все, что родитель пишет в pipe, ребенок будет читать из stdin
        dup2(pipe1[0], STDIN_FILENO);
        
        // Закрываем оригинальный дескриптор чтения из pipe
        close(pipe1[0]);
        
        // Заменяем образ процесса на программу child
        // execl загружает и выполняет программу ./child с аргументом filename
        execl("./child", "child", filename, NULL);
        
        // Этот код выполнится только если execl не удался
        write_str(STDERR_FILENO, "Error: exec failed\n");
        exit(1); // Аварийное завершение дочернего процесса
    } 
    // Код для РОДИТЕЛЬСКОГО процесса (pid > 0)
    else {
        // Родительский процесс
        
        // Закрываем конец pipe для ЧТЕНИЯ, так как родитель только пишет
        close(pipe1[0]);
        
        // Вывод инструкций для пользователя
        write_str(STDOUT_FILENO, "Enter numbers separated by spaces. Type 'exit' to quit:\n");
        
        char buffer[1024]; // Буфер для хранения ввода пользователя
        
        // Основной цикл взаимодействия с пользователем
        while (1) {
            // Вывод приглашения для ввода
            write_str(STDOUT_FILENO, "> ");
            
            // Чтение ввода пользователя с клавиатуры
            bytes = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
            if (bytes <= 0) break; // Если ошибка чтения или конец ввода - выходим
            
            buffer[bytes] = '\0'; // Завершаем строку нулевым символом
            
            // Отправляем введенные данные дочернему процессу через pipe
            write(pipe1[1], buffer, bytes);
            
            // Проверяем, не ввел ли пользователь команду выхода
            if (strstr(buffer, "exit") != NULL) {
                break; // Выходим из цикла если найдено "exit"
            }
        }
        
        // Закрываем конец pipe для записи - это сигнал дочернему процессу о завершении
        close(pipe1[1]);
        
        // Ожидаем завершения дочернего процесса
        // wait приостанавливает выполнение родителя пока ребенок не завершится
        wait(NULL);
        
        // Сообщение об успешном завершении
        write_str(STDOUT_FILENO, "Program finished. Check the file.\n");
    }
    
    return 0; // Успешное завершение программы
}