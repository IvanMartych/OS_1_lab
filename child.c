#include <unistd.h>   // Для системных вызовов: read, write, close, STDIN_FILENO, STDERR_FILENO
#include <fcntl.h>    // Для работы с файлами: open, O_WRONLY, O_CREAT, O_TRUNC
#include <stdlib.h>   // Для преобразования строк: strtod
#include <string.h>   // Для работы со строками: strstr

/**
 * Функция для записи строки в файловый дескриптор
 * @param fd - файловый дескриптор для записи
 * @param str - строка для записи
 */
void write_str(int fd, const char* str) {
    int len = 0;
    // Ручной подсчет длины строки
    while (str[len] != '\0') len++;
    // Запись с помощью системного вызова
    write(fd, str, len);
}

/**
 * Функция преобразования числа float в строку
 * Создает строковое представление числа с двумя знаками после запятой
 * @param num - число для преобразования
 * @param buf - буфер для записи результата (должен быть не менее 32 байт)
 */
void float_to_str(float num, char* buf) {
    int pos = 0; // Текущая позиция в буфере
    
    // Обработка отрицательных чисел
    if (num < 0) {
        buf[pos++] = '-'; // Добавляем знак минус
        num = -num;       // Работаем с положительным числом
    }
    
    // Разделение числа на целую и дробную части
    int integer = (int)num;        // Целая часть (отбрасываем дробную)
    float fraction = num - integer; // Дробная часть
    
    // Преобразование ЦЕЛОЙ части числа в строку
    if (integer == 0) {
        // Если целая часть равна 0, просто записываем '0'
        buf[pos++] = '0';
    } else {
        char temp[20];  // Временный буфер для цифр в обратном порядке
        int temp_len = 0; // Длина временного буфера
        int n = integer;  // Рабочая копия целой части
        
        // Извлекаем цифры числа в ОБРАТНОМ порядке (справа налево)
        while (n > 0) {
            // Получаем последнюю цифру числа и преобразуем в символ
            temp[temp_len++] = '0' + (n % 10);
            n /= 10; // Убираем последнюю цифру
        }
        
        // Разворачиваем цифры в ПРАВИЛЬНОМ порядке (слева направо)
        for (int i = temp_len - 1; i >= 0; i--) {
            buf[pos++] = temp[i];
        }
    }
    
    // Добавляем десятичную точку
    buf[pos++] = '.';
    
    // Преобразование ДРОБНОЙ части в строку (2 знака после запятой)
    // Умножаем дробную часть на 100 и округляем до целого
    int frac_part = (int)(fraction * 100 + 0.5); // +0.5 для правильного округления
    
    // Первая цифра после точки (десятки)
    buf[pos++] = '0' + (frac_part / 10);
    // Вторая цифра после точки (единицы)
    buf[pos++] = '0' + (frac_part % 10);
    
    buf[pos] = '\0'; // Завершаем строку
}

/**
 * Главная функция дочернего процесса
 * Читает числа из pipe, вычисляет их сумму и записывает в файл
 * @param argc - количество аргументов командной строки
 * @param argv - массив аргументов (argv[1] - имя файла для результатов)
 */
int main(int argc, char* argv[]) {
    // Проверка наличия аргумента с именем файла
    if (argc < 2) {
        write_str(STDERR_FILENO, "Error: filename argument required\n");
        return 1; // Завершение с ошибкой
    }
    
    // Открытие файла для записи результатов
    // O_WRONLY - только запись, O_CREAT - создать если не существует, O_TRUNC - очистить если существует
    // 0644 - права доступа: владелец читает/пишет, остальные только читают
    int file_fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (file_fd == -1) {
        write_str(STDERR_FILENO, "Error: cannot open output file\n");
        return 1; // Завершение с ошибкой
    }
    
    char buffer[1024];    // Буфер для чтения данных из pipe
    float numbers[100];   // Массив для хранения чисел (максимум 100 чисел за раз)
    
    // Основной цикл обработки данных от родительского процесса
    while (1) {
        // Чтение данных из стандартного ввода (который перенаправлен на pipe)
        int bytes = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
        if (bytes <= 0) break; // Если конец данных или ошибка - выходим
        
        buffer[bytes] = '\0'; // Завершаем строку нулевым символом
        
        // Проверяем, не прислал ли родитель команду выхода
        if (strstr(buffer, "exit") != NULL) {
            break; // Завершаем цикл если получена команда exit
        }
        
        // ПАРСИНГ ЧИСЕЛ из полученной строки
        int count = 0;        // Счетчик найденных чисел
        char* ptr = buffer;   // Указатель на текущую позицию в буфере
        
        // Обрабатываем строку пока не конец или не заполнен массив чисел
        while (*ptr != '\0' && count < 100) {
            // Пропускаем пробелы, табуляции и переводы строк
            while (*ptr == ' ' || *ptr == '\t' || *ptr == '\n') ptr++;
            if (*ptr == '\0') break; // Если после пропуска конец строки - выходим
            
            // Преобразование подстроки в число с помощью strtod
            char* end; // Указатель на первый символ после числа
            float num = strtod(ptr, &end);
            
            // Если преобразование удалось (end != ptr значит нашли число)
            if (end != ptr) {
                numbers[count++] = num; // Сохраняем число в массив
                ptr = end; // Перемещаем указатель на позицию после числа
            } else {
                // Если не число, пропускаем один символ
                ptr++;
            }
        }
        
        // Если найдены числа для обработки
        if (count > 0) {
            float total = 0; // Переменная для суммы
            
            // ВЫЧИСЛЕНИЕ СУММЫ всех найденных чисел
            for (int i = 0; i < count; i++) {
                total += numbers[i]; // Простое арифметическое сложение
            }
            
            // ЗАПИСЬ РЕЗУЛЬТАТОВ В ФАЙЛ
            
            // Записываем заголовок "Numbers:"
            write_str(file_fd, "Numbers:");
            
            char num_buf[32]; // Буфер для строкового представления числа
            
            // Записываем все числа через пробел
            for (int i = 0; i < count; i++) {
                write_str(file_fd, " "); // Пробел между числами
                float_to_str(numbers[i], num_buf); // Преобразуем число в строку
                write_str(file_fd, num_buf); // Записываем число
            }
            
            // Записываем сумму
            write_str(file_fd, "\nSum: ");
            float_to_str(total, num_buf); // Преобразуем сумму в строку
            write_str(file_fd, num_buf);  // Записываем сумму
            write_str(file_fd, "\n\n");   // Два перевода строки для разделения групп
        }
    }
    
    // Закрываем файл с результатами
    close(file_fd);
    return 0; // Успешное завершение
}